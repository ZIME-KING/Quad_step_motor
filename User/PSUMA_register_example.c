/**
 * @file PSUMA_register_example.c
 * @brief PSUMA寄存器控制功能使用示例
 * @author Generated by AI Assistant
 * @date 2024
 */

#include "control.h"
#include "main.h"
#include <stdio.h>

/**
 * @brief PSUMA寄存器控制使用示例
 * 演示如何通过0x24寄存器的0-11位设置和读取PSUMA值
 */
void PSUMA_Register_Usage_Example(void)
{
    printf("=== PSUMA寄存器控制示例 ===\r\n");
    
    // 示例1: 读取当前PSUMA值
    uint16_t current_psuma = Get_PSUMA_From_Register();
    printf("当前PSUMA值: 0x%03X (%d)\r\n", current_psuma, current_psuma);
    
    // 示例2: 设置不同的PSUMA值
    uint16_t test_values[] = {0x000, 0x0FF, 0x1FF, 0x3FF, 0x7FF, 0xFFF};
    int num_tests = sizeof(test_values) / sizeof(test_values[0]);
    
    for (int i = 0; i < num_tests; i++) {
        printf("\r\n--- 测试 %d ---\r\n", i + 1);
        
        // 设置新的PSUMA值
        printf("设置PSUMA值为: 0x%03X (%d)\r\n", test_values[i], test_values[i]);
        Set_PSUMA_Via_Register(test_values[i]);
        
        // 延时一段时间
        HAL_Delay(100);
        
        // 读取并验证设置的值
        uint16_t read_value = Get_PSUMA_From_Register();
        printf("读取到的PSUMA值: 0x%03X (%d)\r\n", read_value, read_value);
        
        // 验证设置是否成功
        if (read_value == test_values[i]) {
            printf("✓ PSUMA设置成功\r\n");
        } else {
            printf("✗ PSUMA设置失败\r\n");
        }
        
        // 检查全局变量PSUMA是否同步更新
        extern uint16_t PSUMA;
        printf("全局变量PSUMA: 0x%03X (%d)\r\n", PSUMA, PSUMA);
    }
    
    // 示例3: 测试边界值
    printf("\r\n=== 边界值测试 ===\r\n");
    
    // 测试最大值 (12位最大值是4095 = 0xFFF)
    printf("设置最大值 0xFFF (4095)\r\n");
    Set_PSUMA_Via_Register(0xFFF);
    HAL_Delay(50);
    uint16_t max_value = Get_PSUMA_From_Register();
    printf("读取到的值: 0x%03X (%d)\r\n", max_value, max_value);
    
    // 测试超出范围的值 (应该被自动限制在12位内)
    printf("\r\n设置超出范围的值 0x1FFF (8191)\r\n");
    Set_PSUMA_Via_Register(0x1FFF);
    HAL_Delay(50);
    uint16_t limited_value = Get_PSUMA_From_Register();
    printf("读取到的值: 0x%03X (%d) - 应该被限制为0xFFF\r\n", limited_value, limited_value);
    
    // 测试最小值
    printf("\r\n设置最小值 0x000 (0)\r\n");
    Set_PSUMA_Via_Register(0x000);
    HAL_Delay(50);
    uint16_t min_value = Get_PSUMA_From_Register();
    printf("读取到的值: 0x%03X (%d)\r\n", min_value, min_value);
    
    printf("\r\nPSUMA寄存器控制示例完成\r\n");
}

/**
 * @brief 动态调整PSUMA值的示例
 * 演示在运行时动态调整步进电机的步数
 */
void Dynamic_PSUMA_Adjustment_Example(void)
{
    printf("=== 动态PSUMA调整示例 ===\r\n");
    
    // 模拟根据不同条件动态调整PSUMA值
    for (int cycle = 0; cycle < 5; cycle++) {
        printf("\r\n--- 调整周期 %d ---\r\n", cycle + 1);
        
        // 根据周期计算不同的PSUMA值
        uint16_t new_psuma = (cycle + 1) * 200; // 200, 400, 600, 800, 1000
        
        printf("设置PSUMA为: %d\r\n", new_psuma);
        Set_PSUMA_Via_Register(new_psuma);
        
        // 模拟一些处理时间
        HAL_Delay(500);
        
        // 验证设置
        uint16_t current = Get_PSUMA_From_Register();
        printf("当前PSUMA: %d\r\n", current);
        
        // 这里可以添加实际的电机控制逻辑
        // 例如: 启动步进电机，执行指定步数等
    }
    
    printf("\r\n动态PSUMA调整示例完成\r\n");
}

/**
 * @brief 0x24寄存器完整性测试
 * 验证PSUMA设置不会影响0x24寄存器的其他位
 */
void Register_0x24_Integrity_Test(void)
{
    printf("=== 0x24寄存器完整性测试 ===\r\n");
    
    uint16_t original_reg;
    
    // 读取原始寄存器值
    Spi__Read(0x24, &original_reg);
    printf("原始0x24寄存器值: 0x%04X\r\n", original_reg);
    printf("原始PSUMA值 (0-11位): 0x%03X\r\n", original_reg & 0x0FFF);
    printf("其他位 (12-15位): 0x%01X\r\n", (original_reg >> 12) & 0x0F);
    
    // 设置新的PSUMA值
    uint16_t new_psuma = 0x555;
    printf("\r\n设置新PSUMA值: 0x%03X\r\n", new_psuma);
    Set_PSUMA_Via_Register(new_psuma);
    
    // 读取更新后的寄存器值
    uint16_t updated_reg;
    Spi__Read(0x24, &updated_reg);
    printf("更新后0x24寄存器值: 0x%04X\r\n", updated_reg);
    printf("新PSUMA值 (0-11位): 0x%03X\r\n", updated_reg & 0x0FFF);
    printf("其他位 (12-15位): 0x%01X\r\n", (updated_reg >> 12) & 0x0F);
    
    // 验证其他位是否保持不变
    uint16_t original_other_bits = (original_reg >> 12) & 0x0F;
    uint16_t updated_other_bits = (updated_reg >> 12) & 0x0F;
    
    if (original_other_bits == updated_other_bits) {
        printf("✓ 寄存器其他位保持不变\r\n");
    } else {
        printf("✗ 寄存器其他位被意外修改\r\n");
    }
    
    // 验证PSUMA位是否正确设置
    uint16_t actual_psuma = updated_reg & 0x0FFF;
    if (actual_psuma == new_psuma) {
        printf("✓ PSUMA位设置正确\r\n");
    } else {
        printf("✗ PSUMA位设置错误\r\n");
    }
    
    printf("\r\n0x24寄存器完整性测试完成\r\n");
}