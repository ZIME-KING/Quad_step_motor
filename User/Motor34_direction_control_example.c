/**
 * @file Motor34_direction_control_example.c
 * @brief 步进电机34方向控制示例 - 演示0xcfff中D12位方向控制的正确使用
 * @author Generated by AI Assistant
 * @date 2024
 * 
 * 重要说明：
 * - 寄存器0x29的值格式：0xcfff中D12位控制方向
 * - D12=0: 正方向运动
 * - D12=1: 负方向运动
 * - D11-D0: 步数 (0-4095)
 * - D15-D13: 保持0xcfff的高4位不变
 */

#include "control.h"
#include "main.h"
#include <stdio.h>

/**
 * @brief 基本方向控制示例
 * 演示如何使用D12位正确控制步进电机方向
 */
void Motor34_Basic_Direction_Control_Example(void)
{
    printf("=== 步进电机34基本方向控制示例 ===\r\n");
    printf("演示0xcfff中D12位方向控制的正确使用\r\n\r\n");
    
    // 示例1：正方向运动100步
    printf("1. 正方向运动100步 (D12=0)\r\n");
    set_34_with_direction(100, 0); // direction=0表示正方向
    printf("   寄存器0x29值: 0x%04X\r\n", (0xcfff & 0xF000) | 100);
    printf("   D12位=0 (正方向), 步数=100\r\n");
    HAL_Delay(1000);
    
    // 示例2：负方向运动150步
    printf("\r\n2. 负方向运动150步 (D12=1)\r\n");
    set_34_with_direction(150, 1); // direction=1表示负方向
    printf("   寄存器0x29值: 0x%04X\r\n", (0xcfff & 0xF000) | 0x1000 | 150);
    printf("   D12位=1 (负方向), 步数=150\r\n");
    HAL_Delay(1000);
    
    // 示例3：正方向运动最大步数
    printf("\r\n3. 正方向运动最大步数4095步 (D12=0)\r\n");
    set_34_with_direction(4095, 0);
    printf("   寄存器0x29值: 0x%04X\r\n", (0xcfff & 0xF000) | 4095);
    printf("   D12位=0 (正方向), 步数=4095 (最大12位值)\r\n");
    HAL_Delay(1000);
    
    // 示例4：负方向运动最大步数
    printf("\r\n4. 负方向运动最大步数4095步 (D12=1)\r\n");
    set_34_with_direction(4095, 1);
    printf("   寄存器0x29值: 0x%04X\r\n", (0xcfff & 0xF000) | 0x1000 | 4095);
    printf("   D12位=1 (负方向), 步数=4095 (最大12位值)\r\n");
    HAL_Delay(1000);
    
    printf("\r\n基本方向控制示例完成\r\n");
}

/**
 * @brief 寄存器位操作详解示例
 * 详细演示0xcfff中各位的作用和操作方法
 */
void Motor34_Register_Bit_Analysis_Example(void)
{
    printf("=== 寄存器0x29位操作详解示例 ===\r\n");
    printf("0xcfff = 1100 1111 1111 1111 (二进制)\r\n");
    printf("位分配：D15-D13保持不变, D12方向位, D11-D0步数\r\n\r\n");
    
    uint16_t base_value = 0xcfff & 0xF000; // 保持高4位
    printf("基础值 (高4位): 0x%04X\r\n", base_value);
    printf("二进制: %04b %04b %04b %04b\r\n\r\n", 
           (base_value >> 12) & 0xF, (base_value >> 8) & 0xF, 
           (base_value >> 4) & 0xF, base_value & 0xF);
    
    // 演示不同步数和方向的寄存器值
    uint16_t test_steps[] = {1, 10, 100, 500, 1000, 2048, 4095};
    int num_tests = sizeof(test_steps) / sizeof(test_steps[0]);
    
    for (int i = 0; i < num_tests; i++) {
        uint16_t steps = test_steps[i];
        
        // 正方向
        uint16_t pos_value = base_value | (steps & 0x0FFF);
        printf("步数=%4d, 正方向: 0x%04X (D12=0)\r\n", steps, pos_value);
        
        // 负方向
        uint16_t neg_value = base_value | 0x1000 | (steps & 0x0FFF);
        printf("步数=%4d, 负方向: 0x%04X (D12=1)\r\n\r\n", steps, neg_value);
    }
    
    printf("寄存器位操作详解示例完成\r\n");
}

/**
 * @brief 方向切换测试示例
 * 演示连续的方向切换操作
 */
void Motor34_Direction_Toggle_Test_Example(void)
{
    printf("=== 方向切换测试示例 ===\r\n");
    
    uint16_t step_sequence[] = {50, 100, 75, 200, 150};
    uint8_t direction_sequence[] = {0, 1, 0, 1, 0}; // 0=正方向, 1=负方向
    const char* direction_names[] = {"正方向", "负方向"};
    
    int sequence_length = sizeof(step_sequence) / sizeof(step_sequence[0]);
    
    for (int i = 0; i < sequence_length; i++) {
        uint16_t steps = step_sequence[i];
        uint8_t direction = direction_sequence[i];
        
        printf("步骤 %d: %s运动 %d 步\r\n", i+1, direction_names[direction], steps);
        
        // 计算寄存器值
        uint16_t register_value;
        if (direction == 0) {
            register_value = (0xcfff & 0xF000) | steps;
        } else {
            register_value = (0xcfff & 0xF000) | 0x1000 | steps;
        }
        
        printf("   寄存器0x29值: 0x%04X\r\n", register_value);
        printf("   D12=%d (%s), 步数=%d\r\n", direction, direction_names[direction], steps);
        
        // 执行运动
        set_34_with_direction(steps, direction);
        
        // 等待运动完成
        HAL_Delay(500);
        printf("   运动完成\r\n\r\n");
    }
    
    printf("方向切换测试示例完成\r\n");
}

/**
 * @brief 边界条件测试示例
 * 测试步数和方向的边界条件
 */
void Motor34_Boundary_Condition_Test_Example(void)
{
    printf("=== 边界条件测试示例 ===\r\n");
    
    // 测试最小步数
    printf("1. 最小步数测试 (1步)\r\n");
    printf("   正方向1步:\r\n");
    set_34_with_direction(1, 0);
    printf("   寄存器值: 0x%04X\r\n", (0xcfff & 0xF000) | 1);
    HAL_Delay(200);
    
    printf("   负方向1步:\r\n");
    set_34_with_direction(1, 1);
    printf("   寄存器值: 0x%04X\r\n", (0xcfff & 0xF000) | 0x1000 | 1);
    HAL_Delay(200);
    
    // 测试最大步数
    printf("\r\n2. 最大步数测试 (4095步)\r\n");
    printf("   正方向4095步:\r\n");
    set_34_with_direction(4095, 0);
    printf("   寄存器值: 0x%04X\r\n", (0xcfff & 0xF000) | 4095);
    HAL_Delay(500);
    
    printf("   负方向4095步:\r\n");
    set_34_with_direction(4095, 1);
    printf("   寄存器值: 0x%04X\r\n", (0xcfff & 0xF000) | 0x1000 | 4095);
    HAL_Delay(500);
    
    // 测试超出范围的步数（应该被限制）
    printf("\r\n3. 超出范围步数测试 (输入5000，应限制为4095)\r\n");
    printf("   正方向5000步 (限制为4095):\r\n");
    set_34_with_direction(5000, 0); // 函数内部会限制为4095
    printf("   实际寄存器值: 0x%04X (步数被限制为4095)\r\n", (0xcfff & 0xF000) | (5000 & 0x0FFF));
    HAL_Delay(500);
    
    // 测试零步数
    printf("\r\n4. 零步数测试\r\n");
    printf("   正方向0步:\r\n");
    set_34_with_direction(0, 0);
    printf("   寄存器值: 0x%04X\r\n", (0xcfff & 0xF000) | 0);
    HAL_Delay(200);
    
    printf("\r\n边界条件测试示例完成\r\n");
}

/**
 * @brief 位置控制系统中的方向控制示例
 * 演示位置控制系统如何正确使用D12位
 */
void Motor34_Position_Control_Direction_Example(void)
{
    printf("=== 位置控制系统方向控制示例 ===\r\n");
    
    // 初始化位置控制系统
    Motor34_ResetPosition();
    Motor34_SetMaxStepsPerCycle(100);
    Motor34_EnablePositionControl();
    
    printf("位置控制系统已初始化\r\n");
    printf("当前位置: %ld\r\n\r\n", Motor34_GetCurrentPosition());
    
    // 测试正方向运动
    printf("1. 设置目标位置为 +300 (正方向)\r\n");
    Motor34_SetTargetPosition(300);
    
    // 模拟几个控制周期
    for (int cycle = 0; cycle < 5 && !Motor34_IsAtTargetPosition(); cycle++) {
        printf("   周期 %d: 当前位置=%ld, 目标位置=%ld, 误差=%ld\r\n", 
               cycle, Motor34_GetCurrentPosition(), Motor34_GetTargetPosition(), Motor34_GetPositionError());
        
        // 手动分析方向控制逻辑
        int32_t error = Motor34_GetPositionError();
        if (error > 0) {
            printf("   → 需要正方向运动，D12位将设置为0\r\n");
        } else if (error < 0) {
            printf("   → 需要负方向运动，D12位将设置为1\r\n");
        }
        
        Motor34_PositionControl();
        HAL_Delay(20);
    }
    
    printf("   到达目标位置: %ld\r\n\r\n", Motor34_GetCurrentPosition());
    
    // 测试负方向运动
    printf("2. 设置目标位置为 -100 (负方向)\r\n");
    Motor34_SetTargetPosition(-100);
    
    // 模拟几个控制周期
    for (int cycle = 0; cycle < 8 && !Motor34_IsAtTargetPosition(); cycle++) {
        printf("   周期 %d: 当前位置=%ld, 目标位置=%ld, 误差=%ld\r\n", 
               cycle, Motor34_GetCurrentPosition(), Motor34_GetTargetPosition(), Motor34_GetPositionError());
        
        // 手动分析方向控制逻辑
        int32_t error = Motor34_GetPositionError();
        if (error > 0) {
            printf("   → 需要正方向运动，D12位将设置为0\r\n");
        } else if (error < 0) {
            printf("   → 需要负方向运动，D12位将设置为1\r\n");
        }
        
        Motor34_PositionControl();
        HAL_Delay(20);
    }
    
    printf("   到达目标位置: %ld\r\n\r\n", Motor34_GetCurrentPosition());
    
    Motor34_DisablePositionControl();
    printf("位置控制系统方向控制示例完成\r\n");
}

/**
 * @brief 寄存器值验证示例
 * 验证不同输入参数产生的寄存器值是否正确
 */
void Motor34_Register_Value_Verification_Example(void)
{
    printf("=== 寄存器值验证示例 ===\r\n");
    printf("验证不同参数组合产生的寄存器0x29值\r\n\r\n");
    
    // 测试用例：{步数, 方向, 期望的寄存器值}
    struct {
        uint16_t steps;
        uint8_t direction;
        uint16_t expected_value;
        const char* description;
    } test_cases[] = {
        {0,    0, (0xcfff & 0xF000) | 0x0000,           "0步，正方向"},
        {1,    0, (0xcfff & 0xF000) | 0x0001,           "1步，正方向"},
        {100,  0, (0xcfff & 0xF000) | 0x0064,           "100步，正方向"},
        {4095, 0, (0xcfff & 0xF000) | 0x0FFF,           "4095步，正方向"},
        {0,    1, (0xcfff & 0xF000) | 0x1000 | 0x0000,  "0步，负方向"},
        {1,    1, (0xcfff & 0xF000) | 0x1000 | 0x0001,  "1步，负方向"},
        {100,  1, (0xcfff & 0xF000) | 0x1000 | 0x0064,  "100步，负方向"},
        {4095, 1, (0xcfff & 0xF000) | 0x1000 | 0x0FFF,  "4095步，负方向"},
    };
    
    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);
    
    for (int i = 0; i < num_cases; i++) {
        uint16_t steps = test_cases[i].steps;
        uint8_t direction = test_cases[i].direction;
        uint16_t expected = test_cases[i].expected_value;
        
        // 计算实际值
        uint16_t actual;
        if (direction == 0) {
            actual = (0xcfff & 0xF000) | (steps & 0x0FFF);
        } else {
            actual = (0xcfff & 0xF000) | 0x1000 | (steps & 0x0FFF);
        }
        
        // 验证结果
        const char* result = (actual == expected) ? "✓ 通过" : "✗ 失败";
        
        printf("测试 %d: %s\r\n", i+1, test_cases[i].description);
        printf("   期望值: 0x%04X\r\n", expected);
        printf("   实际值: 0x%04X\r\n", actual);
        printf("   结果: %s\r\n\r\n", result);
    }
    
    printf("寄存器值验证示例完成\r\n");
}

/**
 * @brief 完整的方向控制演示
 * 综合演示所有方向控制功能
 */
void Motor34_Complete_Direction_Control_Demo(void)
{
    printf("=== 步进电机34完整方向控制演示 ===\r\n");
    printf("演示0xcfff中D12位方向控制的完整功能\r\n\r\n");
    
    // 1. 基本方向控制
    printf("1. 执行基本方向控制示例...\r\n");
    Motor34_Basic_Direction_Control_Example();
    HAL_Delay(1000);
    
    // 2. 寄存器位操作详解
    printf("\r\n2. 执行寄存器位操作详解...\r\n");
    Motor34_Register_Bit_Analysis_Example();
    HAL_Delay(1000);
    
    // 3. 方向切换测试
    printf("\r\n3. 执行方向切换测试...\r\n");
    Motor34_Direction_Toggle_Test_Example();
    HAL_Delay(1000);
    
    // 4. 边界条件测试
    printf("\r\n4. 执行边界条件测试...\r\n");
    Motor34_Boundary_Condition_Test_Example();
    HAL_Delay(1000);
    
    // 5. 位置控制系统方向控制
    printf("\r\n5. 执行位置控制系统方向控制...\r\n");
    Motor34_Position_Control_Direction_Example();
    HAL_Delay(1000);
    
    // 6. 寄存器值验证
    printf("\r\n6. 执行寄存器值验证...\r\n");
    Motor34_Register_Value_Verification_Example();
    
    printf("\r\n=== 完整方向控制演示结束 ===\r\n");
    printf("总结：\r\n");
    printf("- 0xcfff的D12位控制步进电机方向\r\n");
    printf("- D12=0: 正方向运动\r\n");
    printf("- D12=1: 负方向运动\r\n");
    printf("- D11-D0: 步数 (0-4095)\r\n");
    printf("- D15-D13: 保持0xcfff的高4位不变\r\n");
}